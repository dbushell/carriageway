function d(o,e={}){let{signal:t,persistent:r}=e;return t?.aborted?Promise.reject(t.reason):new Promise((n,i)=>{let s=()=>{clearTimeout(a),i(t?.reason)},a=setTimeout(()=>{t?.removeEventListener("abort",s),n()},o);if(t?.addEventListener("abort",s,{once:!0}),r===!1)try{Deno.unrefTimer(a)}catch(h){if(!(h instanceof ReferenceError))throw h;console.error("`persistent` option is only available in Deno")}})}function c(){let o,e="pending",t=new Promise((r,n)=>{o={async resolve(i){await i,e="fulfilled",r(i)},reject(i){e="rejected",n(i)}}});return Object.defineProperty(t,"state",{get:()=>e}),Object.assign(t,o)}var u=class extends Error{constructor(e){super(e),this.name="QueueError"}},f=class o{#u;#t;#e;#r;#i=0;#s=new Map;#n;#d=0;#h=0;constructor(e){this.concurrency=e?.concurrency??1,this.throttle=e?.throttle??0,this.#t&&this.#u>1&&(this.#n=new o({throttle:this.#t,concurrency:1}),this.#t=0)}get concurrency(){return this.#u}set concurrency(e){this.#u=Math.max(e,1)}get throttle(){return this.#n?.throttle??this.#t}set throttle(e){e=Math.max(e,0),this.#n?this.#n.throttle=e:this.#t=e}get pending(){return this.#s.size}get waiting(){return this.#i}get length(){return this.pending+this.waiting}has(e){for(let t of this.#o())if(t.item===e)return!0;return!1}get(e){if(this.#s.has(e))return this.#s.get(e).deferred;for(let t of this.#o())if(t.item===e)return t.deferred}getPending(){return Array.from(this.#s.keys())}getWaiting(){return Array.from(this.#o()).map(e=>e.item)}add(e,t,r=!1){let n=this.get(e);if(n)return n;let i=c(),s={item:e,deferred:i,callback:t};return this.#i?r?(s.next=this.#e,this.#e=s):(this.#r.next=s,this.#r=s):(this.#e=s,this.#r=s),this.#i++,this.#a(),i}append(e,t){return this.add(e,t)}prepend(e,t){return this.add(e,t,!0)}sort(e){let t=Array.from(this.#o());t.sort((r,n)=>e(r.item,n.item)),this.#e=void 0,this.#i=t.length;for(let r of t){if(r.next=void 0,this.#e){this.#r.next=r,this.#r=r;continue}this.#e=r,this.#r=r}}clear(){this.#n?.clear();for(let e of this.#o())e.deferred.reject(new u("Queue cleared"));this.#e=void 0,this.#r=void 0,this.#i=0}*#o(){let e=this.#e;for(;e;)yield e,e=e.next}#a(){if(!this.waiting||this.pending>=this.#u)return;let e=this.#e;this.#e=e?.next,this.#i--,this.#s.set(e.item,e);let t=()=>this.#c(e.item,e);this.#n?this.#n.append(this.#d++,t).catch(r=>e.deferred.reject(r)):t(),this.#a()}async#c(e,{deferred:t,callback:r}){if(this.#t){let n=performance.now()-this.#h;n<this.#t&&await d(this.#t-n),this.#h=performance.now()}Promise.resolve(r(e)).then(t.resolve).catch(t.reject).finally(()=>{this.#s.delete(e),this.#a()})}};export{f as Queue,u as QueueError};
