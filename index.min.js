function l(s,e={}){let{signal:t,persistent:r=!0}=e;return t?.aborted?Promise.reject(t.reason):new Promise((n,a)=>{let o=()=>{clearTimeout(u),a(t?.reason)},u=setTimeout(()=>{t?.removeEventListener("abort",o),n()},s);if(t?.addEventListener("abort",o,{once:!0}),r===!1)try{Deno.unrefTimer(u)}catch(c){if(!(c instanceof ReferenceError))throw c;console.error("`persistent` option is only available in Deno")}})}var i=class extends Error{constructor(e){super(e),this.name="QueueError"}};var m=class s{#a;#t;#e;#r;#n=0;#i=new Map;#o;#l=0;#c=0;constructor(e){this.concurrency=e?.concurrency??1,this.throttle=e?.throttle??0,this.#t&&this.#a>1&&(this.#o=new s({throttle:this.#t,concurrency:1}),this.#t=0)}get concurrency(){return this.#a}set concurrency(e){this.#a=Math.max(e,1)}get throttle(){return this.#o?.throttle??this.#t}set throttle(e){e=Math.max(e,0),this.#o?this.#o.throttle=e:this.#t=e}get pending(){return this.#i.size}get waiting(){return this.#n}get length(){return this.pending+this.waiting}has(e){for(let t of this.#s())if(t.item===e)return!0;return!1}get(e){if(this.#i.has(e))return this.#i.get(e).deferred.promise;for(let t of this.#s())if(t.item===e)return t.deferred.promise}getPending(){return Array.from(this.#i.keys())}getWaiting(){return Array.from(this.#s()).map(e=>e.item)}add(e,t,r=!1){let n=this.get(e);if(n)return n;let a=Promise.withResolvers(),o={item:e,deferred:a,callback:t};return this.#n?r?(o.next=this.#e,this.#e=o):(this.#r.next=o,this.#r=o):(this.#e=o,this.#r=o),this.#n++,this.#u(),a.promise}append(e,t){return this.add(e,t)}prepend(e,t){return this.add(e,t,!0)}cancel(e){let t;for(let r of this.#s()){if(r.item===e)return r===this.#e?this.#e=r.next:t&&(t.next=r.next),this.#n--,r.deferred.reject(new i("Item cancelled")),!0;t=r}return!1}sort(e){let t=Array.from(this.#s());t.sort((r,n)=>e(r.item,n.item)),this.#e=void 0,this.#n=t.length;for(let r of t){if(r.next=void 0,this.#e){this.#r.next=r,this.#r=r;continue}this.#e=r,this.#r=r}}clear(){this.#o?.clear();for(let e of this.#s())e.deferred.reject(new i("Queue cleared"));this.#e=void 0,this.#r=void 0,this.#n=0}*#s(){let e=this.#e;for(;e;)yield e,e=e.next}#u(){if(!this.waiting||this.pending>=this.#a)return;let e=this.#e;this.#e=e?.next,this.#n--,this.#i.set(e.item,e);let t=()=>this.#m(e.item,e);this.#o?this.#o.append(this.#l++,t).catch(r=>e.deferred.reject(r)):t(),this.#u()}async#m(e,{deferred:t,callback:r}){if(this.#t){let n=performance.now()-this.#c;n<this.#t&&await l(this.#t-n),this.#c=performance.now()}Promise.resolve(r(e)).then(t.resolve).catch(t.reject).finally(()=>{this.#i.delete(e),this.#u()})}};export{m as Queue};
