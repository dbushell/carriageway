function a(i,e={}){let{signal:t,persistent:r}=e;return t?.aborted?Promise.reject(t.reason):new Promise((n,s)=>{let o=()=>{clearTimeout(c),s(t?.reason)},c=setTimeout(()=>{t?.removeEventListener("abort",o),n()},i);if(t?.addEventListener("abort",o,{once:!0}),r===!1)try{Deno.unrefTimer(c)}catch(l){if(!(l instanceof ReferenceError))throw l;console.error("`persistent` option is only available in Deno")}})}var u=class extends Error{constructor(e){super(e),this.name="QueueError"}},m=class i{#a;#t;#e;#r;#o=0;#i=new Map;#n;#l=0;#c=0;constructor(e){this.concurrency=e?.concurrency??1,this.throttle=e?.throttle??0,this.#t&&this.#a>1&&(this.#n=new i({throttle:this.#t,concurrency:1}),this.#t=0)}get concurrency(){return this.#a}set concurrency(e){this.#a=Math.max(e,1)}get throttle(){return this.#n?.throttle??this.#t}set throttle(e){e=Math.max(e,0),this.#n?this.#n.throttle=e:this.#t=e}get pending(){return this.#i.size}get waiting(){return this.#o}get length(){return this.pending+this.waiting}has(e){for(let t of this.#s())if(t.item===e)return!0;return!1}get(e){if(this.#i.has(e))return this.#i.get(e).deferred.promise;for(let t of this.#s())if(t.item===e)return t.deferred.promise}getPending(){return Array.from(this.#i.keys())}getWaiting(){return Array.from(this.#s()).map(e=>e.item)}add(e,t,r=!1){let n=this.get(e);if(n)return n;let s=Promise.withResolvers(),o={item:e,deferred:s,callback:t};return this.#o?r?(o.next=this.#e,this.#e=o):(this.#r.next=o,this.#r=o):(this.#e=o,this.#r=o),this.#o++,this.#u(),s.promise}append(e,t){return this.add(e,t)}prepend(e,t){return this.add(e,t,!0)}sort(e){let t=Array.from(this.#s());t.sort((r,n)=>e(r.item,n.item)),this.#e=void 0,this.#o=t.length;for(let r of t){if(r.next=void 0,this.#e){this.#r.next=r,this.#r=r;continue}this.#e=r,this.#r=r}}clear(){this.#n?.clear();for(let e of this.#s())e.deferred.reject(new u("Queue cleared"));this.#e=void 0,this.#r=void 0,this.#o=0}*#s(){let e=this.#e;for(;e;)yield e,e=e.next}#u(){if(!this.waiting||this.pending>=this.#a)return;let e=this.#e;this.#e=e?.next,this.#o--,this.#i.set(e.item,e);let t=()=>this.#m(e.item,e);this.#n?this.#n.append(this.#l++,t).catch(r=>e.deferred.reject(r)):t(),this.#u()}async#m(e,{deferred:t,callback:r}){if(this.#t){let n=performance.now()-this.#c;n<this.#t&&await a(this.#t-n),this.#c=performance.now()}Promise.resolve(r(e)).then(t.resolve).catch(t.reject).finally(()=>{this.#i.delete(e),this.#u()})}};export{m as Queue,u as QueueError};
